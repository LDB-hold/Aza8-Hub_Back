# API v1 (HTTP/REST)

> Status: draft (perfil operacional inicial: **MVP**)

Este documento descreve os contratos HTTP expostos pelo backend do Aza8 Hub para consumo por clientes (futuro frontend) e integrações.

## Base path e versionamento
- Base path: `/v1`
- Mudanças breaking devem criar uma nova versão (`/v2`) sem quebrar `/v1`.

## Autenticação

### Usuários finais (JWT)
- Header: `Authorization: Bearer <JWT>`
- Assinatura: RS256.
- Claims mínimos:
  - `sub`: `userId`
  - `tenantId`: UUID do tenant
  - `role`/`groups`: papel ou grupos do usuário
  - `type`: `user`
  - `exp`, `jti`

### Service accounts (API key)
- Header (padrão): `Authorization: Bearer <API_KEY>`
- Header alternativo (opcional): `X-API-Key: <API_KEY>` (usar apenas quando o cliente não consegue enviar `Authorization`)
- Formato recomendado (para evitar ambiguidade): prefixo `aza8_sk_` + token opaco **sem** `.` (ponto).
- A API key é vinculada a um único tenant e possui escopo por `tool_action` (ou perfis como read-only/write/admin).
- `X-Tenant-Id` é aceito **apenas** para service accounts (ver “Resolução de tenant”).

### Como o backend diferencia JWT vs API key
- JWT: 3 partes base64url separadas por `.` (ex.: `xxxxx.yyyyy.zzzzz`).
- API key: token opaco (recomendado com prefixo `aza8_sk_`) sem `.`.
- Se o formato for ambíguo/ inválido: `401 INVALID_TOKEN`.

## Resolução de tenant
- Fonte principal: `tenantId` do token (JWT) ou tenant derivado da API key.
- Header: `X-Tenant-Id` (case-insensitive) aceito somente para service accounts/API keys.
- Conflito:
  - Se `X-Tenant-Id` vier e for diferente do tenant do token/API key → `400 TENANT_MISMATCH`.
- Payload: o cliente **não** informa `tenantId` em body; o backend injeta `tenantId` pelo contexto.

## Headers padrão
- `Content-Type: application/json`
- `Accept: application/json`
- `X-Request-Id` (opcional): se enviado, será propagado/ecoado; caso contrário, o backend gera um.
- `Idempotency-Key` (opcional, recomendado em writes críticos): ver “Idempotência”.

## Envelope de resposta
- Sucesso:
  - `{ "data": <payload>, "meta": { ... }? }`
- Erro:
  - `{ "error": { "code": string, "message": string, "details"?: object, "requestId": string } }`

## Governança de erros
- O cliente deve usar `error.code` como chave estável de tratamento (UI/fluxos).
- `message` é segura para o usuário (sem stack trace/SQL/PII).
- `details` é opcional e não deve conter PII nem segredos.

### Códigos e HTTP (principais)
- `VALIDATION_ERROR` → 400
- `TENANT_MISMATCH` → 400
- `UNAUTHORIZED` / `INVALID_TOKEN` / `TOKEN_EXPIRED` → 401
- `TENANT_NOT_FOUND` → 401 (padrão recomendado para evitar enumeração)
- `TENANT_SUSPENDED` → 403
- `FORBIDDEN_ACTION` → 403
- `NOT_FOUND` → 404
- `CONFLICT` / `DUPLICATE_RESOURCE` → 409
- `RATE_LIMITED` → 429
- `INTERNAL_ERROR` / `DATABASE_ERROR` → 500
- `SERVICE_UNAVAILABLE` → 503

## Paginação, filtros e ordenação

### Paginação (cursor)
- Query params:
  - `limit` (default recomendado: 50; máximo sugerido: 100)
  - `cursor` (opaco)
- Resposta:
  - `meta.nextCursor`
  - `meta.hasMore`

### Filtros e sort
- Filtros comuns (quando aplicável): `status`, `q`, `createdAtFrom`, `createdAtTo`
- Sort: `sort=<field>:<asc|desc>` (ex.: `sort=created_at:desc`)

## Idempotência
- Endpoints de criação/provisionamento devem aceitar `Idempotency-Key`.
- O backend persiste a chave por (`tenant_id`, `handler`, `key`) e retorna a mesma resposta em replays.
- Se a mesma `Idempotency-Key` for reutilizada com payload diferente (hash diferente), retornar `409 CONFLICT` (ou um código específico de conflito de idempotência).

## Rate limit (MVP)
- Rate limit por tenant e por rota/categoria (inicialmente pode ser simples; evolui com infra/borda).
- Excedeu: `429 RATE_LIMITED`.

## RBAC e `tool_action`
- Cada rota protegida mapeia para um `tool_action` estável (ex.: `catalog.tools.create`).
- A autorização é feita por grupo/permissão (`group_permission.tool_action_id`) e por escopo de API key.

## Endpoints

### Health
**GET** `/health`
- Auth: não
- Resposta: `{ "data": { "status": "ok" } }`

### Metrics (Prometheus)
**GET** `/metrics`
- Auth: restrito (token de métricas)
  - `Authorization: Bearer <METRICS_TOKEN>` **ou**
  - `X-Metrics-Token: <METRICS_TOKEN>`
- Resposta: formato Prometheus (`text/plain`)

### Perfil
**GET** `/v1/me`
- Auth: JWT (user)
- Resposta (exemplo):
  - `data.user { id, email, name, status }`
  - `data.tenant { id, slug, name, status }`
  - `data.roles`/`data.groups`

### Tenants (Aza8)

**POST** `/v1/tenants`
- Auth: `ADM_AZA8`
- Objetivo: criar tenant + associar pacote inicial + criar usuário `ADM_CLIENTE`.
- Body:
  - `slug`: string (único)
  - `name`: string
  - `packageKey`: string
  - `adminUser`: `{ email: string, name: string }`
- Resposta: tenant + admin criado (e, opcionalmente, credencial/invite inicial).

**POST** `/v1/tenants/{tenantId}/packages/{packageKey}/assign`
- Auth: `ADM_AZA8`
- Objetivo: vincular pacote ao tenant (idempotente para o mesmo par tenant+package).
- Body opcional: `{ "expiresAt"?: string(ISO) }`

**POST** `/v1/tenants/{tenantId}/seeds`
- Auth: `ADM_AZA8`
- Objetivo: rodar seeds base do tenant (grupos/papéis/permissões iniciais).

### Catálogo e pacotes (Aza8)

**POST** `/v1/catalog/tools`
- Auth: `ADM_AZA8`
- Body: `{ key, name, description?, status? }`

**GET** `/v1/catalog/tools`
- Auth: `ADM_AZA8` (ou leitura para `ADM_CLIENTE`, conforme regra de negócio)
- Paginação: cursor (`limit`, `cursor`)

**POST** `/v1/catalog/tools/{toolKey}/actions`
- Auth: `ADM_AZA8`
- Body: `{ key, name, description?, status? }`

**POST** `/v1/catalog/packages`
- Auth: `ADM_AZA8`
- Body: `{ key, name, description?, status? }`

**GET** `/v1/catalog/packages`
- Auth: `ADM_AZA8`
- Paginação: cursor (`limit`, `cursor`)

**POST** `/v1/catalog/packages/{packageKey}/actions`
- Auth: `ADM_AZA8`
- Objetivo: definir/compor ações do pacote.
- Body (exemplo): `{ "toolActionKeys": ["catalog.tools.create", "rbac.users.read"] }`

### Usuários (tenant)

**POST** `/v1/users`
- Auth: `ADM_CLIENTE`
- Body: `{ email, name, groupIds?: string[] }`

**GET** `/v1/users`
- Auth: `ADM_CLIENTE`
- Paginação/filtros: `limit`, `cursor`, `status`, `q`

**PATCH** `/v1/users/{id}`
- Auth: `ADM_CLIENTE`
- Body: `{ name?: string }`

**PATCH** `/v1/users/{id}/status`
- Auth: `ADM_CLIENTE`
- Body: `{ status: "ativo" | "suspenso", suspendedReason?: string }`

### Grupos (tenant)

**POST** `/v1/groups`
- Auth: `ADM_CLIENTE`
- Body: `{ name, description?, status? }`

**GET** `/v1/groups`
- Auth: `ADM_CLIENTE`
- Paginação/filtros: `limit`, `cursor`, `status`, `q`

**PATCH** `/v1/groups/{id}`
- Auth: `ADM_CLIENTE`
- Body: `{ name?: string, description?: string }`

**PATCH** `/v1/groups/{id}/status`
- Auth: `ADM_CLIENTE`
- Body: `{ status: "ativo" | "suspenso", suspendedReason?: string }`

**POST** `/v1/groups/{id}/users/{userId}`
- Auth: `ADM_CLIENTE`
- Objetivo: adicionar usuário ao grupo (idempotente).

**DELETE** `/v1/groups/{id}/users/{userId}`
- Auth: `ADM_CLIENTE`
- Objetivo: remover usuário do grupo (idempotente).

**POST** `/v1/groups/{id}/permissions`
- Auth: `ADM_CLIENTE`
- Body: `{ toolActionKeys: string[] }`

**DELETE** `/v1/groups/{id}/permissions/{permissionId}`
- Auth: `ADM_CLIENTE`

### API keys (tenant)

**POST** `/v1/api-keys`
- Auth: `ADM_CLIENTE`
- Body (exemplos):
  - Por escopo: `{ name: string, toolActionKeys: string[] }`
  - Por perfil: `{ name: string, profile: "read-only" | "write" | "admin" }`
- Resposta: inclui o valor da key **somente na criação**.

**GET** `/v1/api-keys`
- Auth: `ADM_CLIENTE`

**PATCH** `/v1/api-keys/{id}/status`
- Auth: `ADM_CLIENTE`
- Body: `{ status: "ativo" | "suspenso" }`

### Auditoria

**GET** `/v1/audit-logs`
- Auth: `ADM_CLIENTE` (escopo do próprio tenant) / `ADM_AZA8` (visão global, se necessário)
- Filtros (exemplos): `actor`, `action`, `entity_type`, `createdAtFrom`, `createdAtTo`
- Retenção (MVP): dados disponíveis por até 90 dias (hot).

### Branding e config (tenant)

**GET** `/v1/branding`
**PUT** `/v1/branding`
- Auth: `ADM_CLIENTE`
- Body (PUT): `{ logoUrl?, primaryColor?, secondaryColor?, domain? }`

**GET** `/v1/config`
**PUT** `/v1/config`
- Auth: `ADM_CLIENTE`
- Body (PUT): `{ flags?: object, limits?: object }`

### Uso (tenant)

**GET** `/v1/usage`
- Auth: `ADM_CLIENTE`
- Query (exemplo): `periodStart`, `periodEnd`, `groupBy=toolAction`

## Webhooks v1 (perfil MVP)
- Event types iniciais: `tenant.created`, `tenant.package.assigned`, `user.created`, `user.updated`, `group.permission.changed`, `api_key.revoked`.
- Recomendação: entrega via outbox/worker com retries e DLQ; payload versionado e assinado (HMAC) por tenant.
